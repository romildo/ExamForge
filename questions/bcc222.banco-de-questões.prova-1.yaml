- id: "P1-01/variation-1"
  title: "Paradigmas - Característica Fundamental"
  subject: "1: Paradigmas"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-01", "paradigmas", "funcional"]
  question: |
    Qual das seguintes características é a mais fundamental para definir uma linguagem como \textbf{puramente funcional}?
  answers:
    - incorrect: |
        A capacidade de usar laços \haskellinline|for| e \haskellinline|while|.
    - incorrect: |
        A ausência de um sistema de tipos estático.
    - correct: |
        O tratamento de funções como valores de primeira classe e a ausência de efeitos colaterais.
    - incorrect: |
        A obrigatoriedade de usar o paradigma de orientação a objetos.
    - incorrect: |
        O uso de ponteiros para manipulação direta da memória.

- id: "P1-01/variation-2"
  title: "Paradigmas - Princípio Nuclear"
  subject: "1: Paradigmas"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-01", "paradigmas", "funcional"]
  question: |
    O núcleo do paradigma de programação puramente funcional baseia-se em qual dos seguintes princípios?
  answers:
    - incorrect: |
        Na manipulação de estado através de variáveis mutáveis.
    - correct: |
        No tratamento de funções como cidadãs de primeira classe e na evitação de efeitos colaterais.
    - incorrect: |
        Na herança de classes para reutilização de código.
    - incorrect: |
        Na compilação just-in-time para otimização de performance.
    - incorrect: |
        Na interação direta com o hardware através de registradores.

- id: "P1-02/variation-1"
  title: "Paradigmas - Transparência Referencial"
  subject: "1: Paradigmas"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-01", "paradigmas", "transparência-referencial"]
  question: |
    O princípio da \textbf{transparência referencial} afirma que uma expressão pode ser substituída pelo seu valor sem mudar o comportamento do programa. Qual das seguintes operações viola este princípio?
  answers:
    - incorrect: |
        \haskellinline|not True|
    - incorrect: |
        \haskellinline|2 + 3|
    - correct: |
        Uma função que utiliza \haskellinline|getLine| para ler uma entrada do teclado.
    - incorrect: |
        \haskellinline|length "Haskell"|
    - incorrect: |
        \haskellinline|tail [1,2,3]|

- id: "P1-02/variation-2"
  title: "Paradigmas - Violação de Transparência Referencial"
  subject: "1: Paradigmas"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-01", "paradigmas", "transparência-referencial"]
  question: |
    O princípio da \textbf{transparência referencial} é violado por qual das seguintes operações?
  answers:
    - incorrect: |
        \haskellinline|length "exemplo"|
    - correct: |
        Uma função que utiliza \haskellinline|randomRIO (1, 10)| para gerar um número.
    - incorrect: |
        \haskellinline|2 * 10|
    - incorrect: |
        \haskellinline|not (1 == 2)|
    - incorrect: |
        \haskellinline|head [1, 2, 3]|

- id: "P2-01/variation-1"
  title: "Ambiente - Função do GHCi"
  subject: "2: Ambiente"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-02", "ambiente", "ghci"]
  question: |
    Qual é a principal função do \textbf{GHCi} no ecossistema Haskell?
  answers:
    - correct: |
        Fornecer um ambiente interativo (REPL) para testar expressões e funções Haskell rapidamente.
    - incorrect: |
        Compilar um arquivo \texttt{.hs} em um programa executável otimizado.
    - incorrect: |
        Gerenciar as dependências e pacotes de um projeto.
    - incorrect: |
        Gerar documentação a partir dos comentários do código.
    - incorrect: |
        Formatar automaticamente o código-fonte para seguir um guia de estilo.

- id: "P2-01/variation-2"
  title: "Ambiente - Ferramenta Interativa"
  subject: "2: Ambiente"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-02", "ambiente", "ghci"]
  question: |
    No desenvolvimento em Haskell, a ferramenta usada para carregar módulos e testar funções interativamente em um terminal é chamada de:
  answers:
    - incorrect: |
        GHC (Glasgow Haskell Compiler)
    - incorrect: |
        Cabal
    - correct: |
        GHCi (GHC interactive)
    - incorrect: |
        Hackage
    - incorrect: |
        Stack

- id: "P2-02/variation-1"
  title: "Ambiente - Hackage e Ferramentas"
  subject: "2: Ambiente"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-02", "ambiente", "hackage", "cabal"]
  question: |
    O \textbf{Hackage} é o principal repositório de pacotes da comunidade Haskell. Qual ferramenta é comumente usada para baixar e instalar pacotes do Hackage em um projeto?
  answers:
    - incorrect: |
        Git
    - incorrect: |
        GHC
    - correct: |
        Cabal (ou Stack)
    - incorrect: |
        Make
    - incorrect: |
        GHCi

- id: "P2-02/variation-2"
  title: "Ambiente - Gerenciamento de Dependências"
  subject: "2: Ambiente"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-02", "ambiente", "cabal", "dependências"]
  question: |
    Para gerenciar dependências de um projeto Haskell, como a biblioteca \haskellinline|random|, e baixá-las do repositório central (Hackage), qual das seguintes ferramentas seria a mais apropriada?
  answers:
    - incorrect: |
        O próprio GHC
    - incorrect: |
        O editor de texto VS Code
    - correct: |
        Cabal
    - incorrect: |
        Git
    - incorrect: |
        O sistema operacional

- id: "P3-01/variation-1"
  title: "Expressões e Definições - let e if"
  subject: "3: Expressões e Definições"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-03", "expressões", "let", "if"]
  question: |
    Qual o valor final da seguinte expressão em Haskell?
    \begin{minted}{haskell}
    let x = 5; y = 10 in if x > y then x * 2 else y * 2
    \end{minted}
  answers:
    - incorrect: |
        10
    - incorrect: |
        5
    - correct: |
        20
    - incorrect: |
        25
    - incorrect: |
        Ocorre um erro de tipo.

- id: "P3-01/variation-2"
  title: "Expressões e Definições - let e if 2"
  subject: "3: Expressões e Definições"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-03", "expressões", "let", "if"]
  question: |
    Qual o valor final da seguinte expressão em Haskell?
    \begin{minted}{haskell}
    let a = 20; b = 4 in if a < b then a + 1 else b + 1
    \end{minted}
  answers:
    - incorrect: |
        21
    - correct: |
        5
    - incorrect: |
        25
    - incorrect: |
        4
    - incorrect: |
        Ocorre um erro de tipo.

- id: "P3-02/variation-1"
  title: "Expressões e Definições - Definição vs Aplicação"
  subject: "3: Expressões e Definições"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-03", "expressões", "definições", "aplicação"]
  question: |
    Analise a seguinte definição:
    \begin{minted}{haskell}
    ehVogal c = c `elem` "aeiouAEIOU"
    \end{minted}
    Neste contexto, \haskellinline|ehVogal| é um(a) \fillin, e \haskellinline|ehVogal 'a'| é um(a) \fillin.
  answers:
    - incorrect: |
        expressão / aplicação de função
    - incorrect: |
        aplicação de função / definição de função
    - incorrect: |
        tipo / valor
    - correct: |
        definição de função / aplicação de função
    - incorrect: |
        variável / tipo

- id: "P3-02/variation-2"
  title: "Expressões e Definições - Definição vs Aplicação 2"
  subject: "3: Expressões e Definições"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-03", "expressões", "definições", "aplicação"]
  question: |
    Analise a seguinte definição:
    \begin{minted}{haskell}
    dobro x = x * 2
    \end{minted}
    Neste contexto, \haskellinline|dobro| é um(a) \fillin, e \haskellinline|dobro 10| é um(a)  \fillin.
  answers:
    - correct: |
        definição de função / aplicação de função
    - incorrect: |
        aplicação de função / definição de função
    - incorrect: |
        tipo / valor
    - incorrect: |
        expressão / aplicação de função
    - incorrect: |
        variável / tipo

- id: "P3-03/variation-1"
  title: "Expressões e Definições - let vs where"
  subject: "3: Expressões e Definições"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-03", "escopo", "let", "where"]
  question: |
    Qual é a principal diferença de escopo entre uma definição local feita com \haskellinline|let...in| e uma feita com \haskellinline|where|?
  answers:
    - incorrect: |
        \haskellinline|where| não permite definir funções locais, apenas constantes.
    - incorrect: |
        Não há diferença, são totalmente intercambiáveis.
    - correct: |
        As definições em \haskellinline|where| são visíveis em todas as guardas da equação, enquanto \haskellinline|let| define uma expressão local que pode ser usada apenas após o \haskellinline|in|.
    - incorrect: |
        \haskellinline|where| só pode ser usado em ações de E/S, enquanto \haskellinline|let| só em funções puras.
    - incorrect: |
        \haskellinline|let| é mais eficiente que \haskellinline|where| para definir funções.

- id: "P4-01/variation-1"
  title: "Tipos de Dados - Assinatura de Função"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "assinaturas"]
  question: |
    Qual das seguintes assinaturas de tipo representa uma função que recebe dois \haskellinline|Int| e uma \haskellinline|String| e retorna um \haskellinline|Bool|?
  answers:
    - incorrect: |
        \haskellinline|(Int, Int, String) -> Bool|
    - incorrect: |
        \haskellinline|Int -> Int -> String, Bool|
    - correct: |
        \haskellinline|Int -> Int -> String -> Bool|
    - incorrect: |
        \haskellinline|[Int, Int, String] -> Bool|
    - incorrect: |
        \haskellinline|Bool -> Int -> Int -> String|

- id: "P4-01/variation-2"
  title: "Tipos de Dados - Assinatura de Função 2"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "assinaturas"]
  question: |
    Qual das seguintes assinaturas de tipo representa uma função que recebe um \haskellinline|Bool| e uma lista de \haskellinline|Char| e retorna um \haskellinline|Char|?
  answers:
    - incorrect: |
        \haskellinline|[Bool] -> [Char] -> Char|
    - correct: |
        \haskellinline|Bool -> [Char] -> Char|
    - incorrect: |
        \haskellinline|(Bool, [Char], Char)|
    - incorrect: |
        \haskellinline|Char -> Bool -> [Char]|
    - incorrect: |
        \haskellinline|(Bool, [Char]) -> Char|

- id: "P4-02/variation-1"
  title: "Tipos de Dados - Integer vs Int"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "integer", "int"]
  question: |
    Para qual dos seguintes valores o tipo \haskellinline|Integer| é mais apropriado que \haskellinline|Int|?
  answers:
    - incorrect: |
        A idade de uma pessoa.
    - incorrect: |
        O número de alunos em uma turma.
    - correct: |
        O resultado do cálculo de \haskellinline|fatorial 100|.
    - incorrect: |
        Um contador em um laço que vai de 1 a 10.
    - incorrect: |
        O número de dias em um mês.

- id: "P4-02/variation-2"
  title: "Tipos de Dados - Int vs Integer"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "integer", "int"]
  question: |
    Para qual dos seguintes valores o tipo \haskellinline|Int| é geralmente suficiente, não necessitando de \haskellinline|Integer|?
  answers:
    - correct: |
        A idade de uma pessoa.
    - incorrect: |
        A população mundial.
    - incorrect: |
        O resultado de \haskellinline|2 ^ 200|.
    - incorrect: |
        A distância em milímetros entre duas galáxias.
    - incorrect: |
        O número de grãos de areia na Terra.

- id: "P4-03/variation-1"
  title: "Tipos de Dados - Tipo de Expressão com Tupla"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "tuplas", "polimorfismo"]
  question: |
    Qual é o tipo da expressão \haskellinline|(True, "Haskell", head [1,2,3])|?
  answers:
    - incorrect: |
        \haskellinline|(Bool, [Char], Int)|
    - incorrect: |
        \haskellinline|[Bool, String, Int]|
    - incorrect: |
        \haskellinline|(Bool, String, Integer)|
    - incorrect: |
        A expressão contém um erro de tipo.
    - correct: |
        \haskellinline|(Bool, String, Num a => a)|

- id: "P4-03/variation-2"
  title: "Tipos de Dados - Tipo de Expressão com Tupla 2"
  subject: "4: Tipos de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-04", "tipos", "tuplas"]
  question: |
    Qual é o tipo da expressão \haskellinline|('a', length "texto", 10.5)|?
  answers:
    - incorrect: |
        \haskellinline|(Char, Int, Float)|
    - incorrect: |
        \haskellinline|[Char, Int, Double]|
    - incorrect: |
        \haskellinline|(Char, Integer, Double)|
    - correct: |
        \haskellinline|(Char, Int, Double)|
    - incorrect: |
        A expressão contém um erro de tipo.

- id: "P5-01/variation-1"
  title: "Definições Locais - let aninhado"
  subject: "5: Definições Locais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-05", "definições-locais", "let"]
  question: |
    Qual o resultado da avaliação da expressão a seguir?
    \begin{minted}{haskell}
    let x = 5
    in let y = x * 2
      in x + y
    \end{minted}
  answers:
    - incorrect: |
        10
    - correct: |
        15
    - incorrect: |
        25
    - incorrect: |
        7
    - incorrect: |
        Erro de escopo.

- id: "P5-01/variation-2"
  title: "Definições Locais - let aninhado 2"
  subject: "5: Definições Locais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-05", "definições-locais", "let"]
  question: |
    Qual o resultado da avaliação da expressão a seguir?
    \begin{minted}{haskell}
    let a = 10
    in let b = a * 2
      in b - a
    \end{minted}
  answers:
    - incorrect: |
        30
    - correct: |
        10
    - incorrect: |
        20
    - incorrect: |
        0
    - incorrect: |
        Erro de escopo.

- id: "P5-02/variation-1"
  title: "Definições Locais - Cláusula where"
  subject: "5: Definições Locais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-05", "definições-locais", "where"]
  question: |
    Analise o código abaixo:
    \begin{minted}{haskell}
    f x = resultado
      where
        resultado = y + 1
        y = x * 2
    \end{minted}
    O que a cláusula \haskellinline|where| está fazendo?
  answers:
    - incorrect: |
        Definindo variáveis globais \haskellinline{resultado} e \haskellinline{y}.
    - incorrect: |
        Importando as funções \haskellinline{resultado} e \haskellinline{y} de um módulo.
    - correct: |
        Definindo \haskellinline{resultado} e \haskellinline{y} como variáveis locais, visíveis apenas dentro da definição de \haskellinline{f}.
    - incorrect: |
        Criando uma tupla com os valores \haskellinline{resultado} e \haskellinline{y}.
    - incorrect: |
        A sintaxe está incorreta.

- id: "P5-03/variation-1"
  title: "Definições Locais - Shadowing com let"
  subject: "5: Definições Locais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-05", "definições-locais", "let", "shadowing"]
  question: |
    Qual o valor da expressão \haskellinline|f 3| para a seguinte definição?
    \begin{minted}{haskell}
    f x =
      let a = 10
      in a + let a = 5
              in x + a
    \end{minted}
  answers:
    - correct: |
        18
    - incorrect: |
        13
    - incorrect: |
        8
    - incorrect: |
        Ocorre um erro devido à redefinição de \haskellinline{a}.
    - incorrect: |
        15

- id: "P5-03/variation-2"
  title: "Definições Locais - Shadowing com let 2"
  subject: "5: Definições Locais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-05", "definições-locais", "let", "shadowing"]
  question: |
    Qual o valor da expressão \haskellinline|f 2| para a seguinte definição?
    \begin{minted}{haskell}
    f x =
      let a = 100
      in x + let a = 1
              in x + a
    \end{minted}
  answers:
    - correct: "5" # Note: My original answer 'A' (103) seems wrong. The logic should be 2 + (1) = 3. Wait, no. it's x + (let... in x+a) -> 2 + (2+1) = 5
    - incorrect: |
        102
    - incorrect: |
        103
    - incorrect: |
        Ocorre um erro devido à redefinição de \haskellinline{a}.
    - incorrect: |
        202

- id: "P6-01/variation-1"
  title: "Estruturas de Dados - Tupla vs Lista"
  subject: "6: Estruturas de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-06", "estruturas-dados", "tuplas", "listas"]
  question: |
    Qual é a principal diferença entre uma tupla e uma lista em Haskell?
  answers:
    - incorrect: |
        Tuplas podem ter um número variável de elementos, enquanto listas têm tamanho fixo.
    - incorrect: |
        Listas são imutáveis, enquanto tuplas podem ser modificadas após a criação.
    - incorrect: |
        Não há diferença, são sinônimos para a mesma estrutura.
    - incorrect: |
        Listas só podem conter números, enquanto tuplas podem conter qualquer tipo.
    - correct: |
        Tuplas têm um tamanho fixo e podem conter elementos de tipos diferentes, enquanto listas têm tamanho variável e elementos do mesmo tipo.

- id: "P6-02/variation-1"
  title: "Estruturas de Dados - Criação de Tupla"
  subject: "6: Estruturas de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-06", "estruturas-dados", "tuplas"]
  question: |
    Qual das seguintes expressões cria uma tupla de 3 elementos (tripla)?
  answers:
    - incorrect: |
        \haskellinline|(1:"a":True)|
    - incorrect: |
        \haskellinline|[1, "a", True]|
    - correct: |
        \haskellinline|(1, "a", True)|
    - incorrect: |
        \haskellinline|1, "a", True|
    - incorrect: |
        \haskellinline|(1, ("a", True))|

- id: "P6-03/variation-1"
  title: "Estruturas de Dados - Definição de String"
  subject: "6: Estruturas de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-06", "estruturas-dados", "string", "listas"]
  question: |
    Como o tipo \haskellinline|String| é, na verdade, definido em Haskell?
  answers:
    - incorrect: |
        Como um tipo de dado primitivo para textos.
    - correct: |
        Como um sinônimo de tipo para uma lista de caracteres (\haskellinline{type String = [Char]}).
    - incorrect: |
        Como uma tupla de caracteres.
    - incorrect: |
        Como um sinônimo para \haskellinline{[String]}.
    - incorrect: |
        Como um tipo especial para entrada e saída.

- id: "P6-04/variation-1"
  title: "Estruturas de Dados - Função lookup"
  subject: "6: Estruturas de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-06", "estruturas-dados", "listas-associação", "lookup"]
  question: |
    A função \haskellinline|lookup| busca uma chave em uma lista de associação. Qual o resultado de \haskellinline|lookup 3 [(1,"a"),(3,"c"),(5,"e")]|?
  answers:
    - incorrect: |
        \haskellinline{\"c\"}
    - incorrect: |
        \haskellinline{Nothing}
    - incorrect: |
        \haskellinline{3}
    - incorrect: |
        Ocorre um erro de tipo.
    - correct: |
        \haskellinline{Just \"c\"}

- id: "P6-05/variation-1"
  title: "Estruturas de Dados - Modelagem de Inventário"
  subject: "6: Estruturas de Dados"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-06", "estruturas-dados", "tipos", "modelagem"]
  question: |
    Você precisa modelar um inventário de produtos. Cada produto tem \haskellinline{Nome (texto)}, \haskellinline{Código (inteiro)} e \haskellinline{Preço (ponto flutuante, opcional)}. Qual tipo representa uma \textbf{lista} desses produtos?
  answers:
    - incorrect: |
        \haskellinline|[String, Int, Maybe Double]|
    - incorrect: |
        \haskellinline|Maybe (String, Int, Double)|
    - incorrect: |
        \haskellinline|(String, Int, Maybe Double)|
    - correct: |
        \haskellinline|[(String, Int, Maybe Double)]|
    - incorrect: |
        \haskellinline|[String]|

- id: "P7-01/variation-1"
  title: "Polimorfismo - Função Polimórfica"
  subject: "7: Polimorfismo"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-07", "polimorfismo", "tipos"]
  question: |
    Qual das seguintes assinaturas de tipo representa uma função \textbf{polimórfica}?
  answers:
    - correct:   |
        \haskellinline|reverse :: [a] -> [a]|
    - incorrect: |
        \haskellinline|soma :: Int -> Int -> Int|
    - incorrect: |
        \haskellinline|ehDez :: Int -> Bool|
    - incorrect: |
        \haskellinline|raizQuadrada :: Double -> Double|
    - incorrect: |
        \haskellinline|ehMaiuscula :: Char -> Bool|

- id: "P7-02/variation-1"
  title: "Polimorfismo - Variáveis de Tipo"
  subject: "7: Polimorfismo"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-07", "polimorfismo", "tipos", "map"]
  question: |
    Na assinatura de tipo \haskellinline|map :: (a -> b) -> [a] -> [b]|, o que as letras \haskellinline{a} e \haskellinline{b} representam?
  answers:
    - incorrect: |
        Tipos concretos, como \haskellinline{Int} e \haskellinline{Bool}.
    - incorrect: |
        Funções que ainda não foram definidas.
    - correct: |
        Variáveis de tipo, que podem ser substituídas por qualquer tipo concreto.
    - incorrect: |
        Nomes de pacotes que precisam ser importados.
    - incorrect: |
        Constantes numéricas.

- id: "P7-03/variation-1"
  title: "Polimorfismo - Vantagem Principal"
  subject: "7: Polimorfismo"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-07", "polimorfismo", "reuso"]
  question: |
    Qual a principal vantagem de usar polimorfismo paramétrico em funções como \haskellinline|length|?
  answers:
    - correct: |
        A mesma função pode ser reutilizada para listas de diferentes tipos.
    - incorrect: |
        A função se torna mais segura.
    - incorrect: |
        A função se torna mais rápida.
    - incorrect: |
        Permite que a função realize ações de E/S.
    - incorrect: |
        O uso de memória é reduzido.

- id: "P8-01/variation-1"
  title: "Sobrecarga - Implementação em Haskell"
  subject: "8: Sobrecarga"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-08", "sobrecarga", "type-classes"]
  question: |
    Em Haskell, a sobrecarga de operadores e funções (polimorfismo ad-hoc) é implementada através do mecanismo de:
  answers:
    - incorrect: |
        Expressões \haskellinline|case|.
    - incorrect: |
        Guardas.
    - incorrect: |
        Expressões lambda.
    - correct: |
        Classes de tipos (Type Classes).
    - incorrect: |
        Módulos.

- id: "P8-02/variation-1"
  title: "Sobrecarga - Restrição de Classe de Tipo"
  subject: "8: Sobrecarga"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-08", "sobrecarga", "type-classes", "show"]
  question: |
    O que a parte \haskellinline|Show a =>| significa na assinatura \haskellinline|show :: Show a => a -> String|?
  answers:
    - incorrect: |
        A função só funciona se o tipo \haskellinline{a} for exatamente o tipo \haskellinline{Show}.
    - correct: |
        A função funciona para qualquer tipo \haskellinline{a}, desde que este tipo seja uma instância da classe de tipo \haskellinline{Show}.
    - incorrect: |
        O resultado da função será do tipo \haskellinline{Show}.
    - incorrect: |
        A função se chama \haskellinline{Show}.
    - incorrect: |
        A função só funciona para um tipo \haskellinline{a} que é um subtipo de \haskellinline{Show}.

- id: "P9-01/variation-1"
  title: "Condicionais - Guardas vs if-then-else"
  subject: "9: Condicionais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-09", "condicionais", "guardas", "if"]
  question: |
    Em qual situação o uso de \textbf{guardas} é mais idiomático do que \haskellinline|if-then-else| aninhado?
  answers:
    - incorrect: |
        Para um único teste booleano com duas alternativas.
    - correct: |
        Para definir uma função com múltiplas condições e vários resultados, como na função \haskellinline{sinal}.
    - incorrect: |
        Guardas e \haskellinline{if-then-else} são sempre intercambiáveis sem perda de legibilidade.
    - incorrect: |
        Para realizar casamento de padrão em uma lista.
    - incorrect: |
        Para definir funções que não recebem argumentos.

- id: "P9-02/variation-1"
  title: "Condicionais - Palavra-chave otherwise"
  subject: "9: Condicionais"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-09", "condicionais", "guardas", "otherwise"]
  question: |
    O que a palavra-chave \haskellinline|otherwise| representa em uma cláusula de guarda?
  answers:
    - incorrect: |
        Uma variável que contém o valor da última guarda testada.
    - incorrect: |
        Uma forma de pular para a próxima equação da função.
    - incorrect: |
        Um sinônimo para o valor booleano \haskellinline|False|.
    - correct: |
        Um sinônimo para o valor booleano \haskellinline|True|, usado para garantir um caso padrão.
    - incorrect: |
        Uma função que retorna um erro.

- id: "P10-01/variation-1"
  title: "E/S - Tipo de putStr"
  subject: "10: E/S"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-10", "io", "putstr"]
  question: |
    Qual é o tipo de \haskellinline|putStr| e o que ele faz?
  answers:
    - incorrect: |
        \haskellinline|IO String| - Lê uma linha de texto.
    - incorrect: |
        \haskellinline|String -> String| - É uma função pura.
    - incorrect: |
        \haskellinline|IO ()| - Apenas imprime uma nova linha.
    - correct: |
        \haskellinline|String -> IO ()| - Imprime uma string, sem nova linha.
    - incorrect: |
        \haskellinline|String -> String -> IO ()| - Recebe duas strings e as imprime.

- id: "P10-02/variation-1"
  title: "E/S - <- vs let em do"
  subject: "10: E/S"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-10", "io", "do-notation", "let"]
  question: |
    Qual a diferença entre \haskellinline|<-| e \haskellinline|let| em um bloco \haskellinline|do|?
  answers:
    - correct: |
        \haskellinline{<-} executa uma ação de E/S e extrai seu valor de retorno, enquanto \haskellinline{let} define um valor ou função pura local.
    - incorrect: |
        \haskellinline|<-| é usado para definir funções, \haskellinline|let| é para constantes.
    - incorrect: |
        Não há diferença, podem ser usados de forma intercambiável.
    - incorrect: |
        \haskellinline{let} executa uma ação de E/S, enquanto \haskellinline{<-} define um valor puro.
    - incorrect: |
        \haskellinline|let| só pode ser usado no início de um bloco \haskellinline|do|.

- id: "P10-03/variation-1"
  title: "E/S - Buffering de Saída"
  subject: "10: E/S"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-10", "io", "buffering"]
  question: |
    Seu programa precisa imprimir um prompt e ler a entrada na mesma linha, mas o prompt só aparece depois. Qual a causa mais provável e a solução?
  answers:
    - incorrect: |
        Causa: O computador está lento; Solução: Reiniciar o computador.
    - correct: |
        Causa: Saída bufferizada; Solução: Usar \haskellinline{hSetBuffering stdout NoBuffering}.
    - incorrect: |
        Causa: \haskellinline{putStr} não funciona para prompts; Solução: Usar \haskellinline{print}.
    - incorrect: |
        Causa: \haskellinline{getLine} é mais rápido que \haskellinline{putStr}; Solução: Adicionar um \haskellinline{delay}.
    - incorrect: |
        Causa: Erro de sintaxe; Solução: Corrigir o código.

- id: "P11-01/variation-1"
  title: "Recursão - Consumo de Pilha"
  subject: "11: Recursão"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-11", "recursão", "pilha"]
  question: |
    Dada a definição da função \haskellinline{somaLista}, qual a consequência da operação \haskellinline{x + ...} ser executada após o retorno da chamada recursiva?
    \begin{minted}{haskell}
    somaLista [] = 0
    somaLista (x:xs) = x + somaLista xs
    \end{minted}
  answers:
    - incorrect: |
        A função só funciona para listas do tipo \haskellinline{[Double]}.
    - correct: |
        Cada chamada recursiva pendente consome espaço na pilha de chamadas.
    - incorrect: |
        A função não consegue somar números negativos.
    - incorrect: |
        Ocorre um erro de compilação.
    - incorrect: |
        A função é otimizada para recursão de cauda.

- id: "P11-02/variation-1"
  title: "Recursão - Vantagem da Recursividade de Cauda"
  subject: "11: Recursão"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-11", "recursão", "recursão-de-cauda", "otimização"]
  question: |
    Qual a principal vantagem da \textbf{recursividade de cauda}?
  answers:
    - incorrect: |
        O código se torna mais fácil de ler para iniciantes.
    - incorrect: |
        A função pode lidar com qualquer tipo de entrada sem erros.
    - correct: |
        Permite que o compilador realize a Otimização de Chamada de Cauda (TCO), fazendo com que a função execute em espaço de pilha constante.
    - incorrect: |
        Ela elimina a necessidade de um caso base na função.
    - incorrect: |
        Ela só funciona para funções que retornam \haskellinline{Integer}.

- id: "P11-03/variation-1"
  title: "Recursão - Técnica do Acumulador"
  subject: "11: Recursão"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-11", "recursão", "acumulador"]
  question: |
    Como funciona a técnica do \textbf{acumulador}?
  answers:
    - incorrect: |
        Armazenando os resultados em um arquivo externo para economizar memória.
    - incorrect: |
        Criando múltiplas chamadas recursivas para acelerar o processo.
    - correct: |
        Adicionando um argumento extra à função que acumula o resultado parcial a cada chamada.
    - incorrect: |
        Usando funções de ordem superior como \haskellinline{map} e \haskellinline{filter} para evitar a recursão.
    - incorrect: |
        Ignorando o caso base e focando apenas no passo recursivo.

- id: "P12-01/variation-1"
  title: "E/S Recursiva - Papel do return"
  subject: "12: E/S Recursiva"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-12", "io", "recursão", "return"]
  question: |
    Qual o papel da função \haskellinline|return| em uma ação de E/S recursiva?
  answers:
    - incorrect: |
        Parar o programa imediatamente com um código de erro.
    - incorrect: |
        Ler um valor do teclado para a próxima iteração.
    - correct: |
        Servir como o caso base, empacotando um valor puro final em uma ação \HASKELLINLINE{IO}.
    - incorrect: |
        Imprimir o resultado final na tela.
    - incorrect: |
        Reiniciar a ação recursiva desde o começo.

- id: "P12-02/variation-1"
  title: "E/S Recursiva - Separação de Responsabilidades"
  subject: "12: E/S Recursiva"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-12, "io", "recursão", "design"]
  question: |
    Qual padrão de design a ação \haskellinline|lerLista| e a chamada \haskellinline|print (sum numeros)| representam?
    \begin{minted}{haskell}
    lerLista = do
        x <- readLn
        if x == 0 then return []
        else do { resto <- lerLista; return (x:resto) }

    main = do
        numeros <- lerLista
        print (sum numeros)
    \end{minted}
  answers:
    - correct: |
        Uma separação de responsabilidades, onde uma ação de E/S coleta dados, e uma função pura os processa.
    - incorrect: |
        Um exemplo de recursividade mútua.
    - incorrect: |
        Uma ação de E/S monolítica que mistura a leitura e o cálculo.
    - incorrect: |
        Um programa que não compila devido a erros de tipo.
    - incorrect: |
        Um exemplo de recursividade de cauda para otimização de memória.

- id: "P13-01/variation-1"
  title: "Padrões - Processamento de Lista"
  subject: "13: Padrões"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-13", "padrões", "listas"]
  question: |
    Qual o resultado da função \haskellinline|processaLista| com a entrada \haskellinline|[10, 20, 30]|?
    \begin{minted}{haskell}
    processaLista :: [Int] -> Int
    processaLista []       = 0
    processaLista [x]      = x
    processaLista (x:y:_) = x + y
    \end{minted}
  answers:
    - incorrect: |
        10
    - correct: "30" # Note: The original answer was C (60), but x+y is 10+20=30
    - incorrect: |
        60
    - incorrect: |
        0
    - incorrect: |
        Erro em tempo de execução.

- id: "P13-02/variation-1"
  title: "Padrões - Princípio da Linearidade"
  subject: "13: Padrões"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-13", "padrões", "linearidade"]
  question: |
    O que o \textbf{princípio da linearidade} estabelece sobre o casamento de padrão em Haskell?
  answers:
    - incorrect: |
        Que todas as funções devem ter um comportamento linear em termos de complexidade.
    - correct: |
        Que uma mesma variável não pode aparecer mais de uma vez em um único padrão.
    - incorrect: |
        Que a ordem dos padrões em uma definição de função não importa.
    - incorrect: |
        Que os padrões só podem ser usados em listas.
    - incorrect: |
        Que todos os padrões devem estar alinhados na mesma coluna.

- id: "P13-03/variation-1"
  title: "Padrões - Processamento de Lista 2"
  subject: "13: Padrões"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-13", "padrões", "listas"]
  question: |
    Qual o resultado da função \haskellinline|processaLista| com a entrada \haskellinline|[10, 20]|?
    \begin{minted}{haskell}
    processaLista :: [Int] -> Int
    processaLista []       = 0
    processaLista [x]      = x
    processaLista (x:y:_) = x - y
    \end{minted}
  answers:
    - incorrect: |
        10
    - incorrect: |
        0
    - incorrect: |
        Erro em tempo de execução.
    - correct: |
        -10
    - incorrect: |
        20

- id: "P14-01/variation-1"
  title: "case - Relação com Múltiplas Equações"
  subject: "14: `case`"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-14", "case", "padrões"]
  question: |
    Qual a relação entre múltiplas equações de função e a expressão \haskellinline{case}?
  answers:
    - incorrect: |
        \haskellinline{if-then-else} é \"açúcar sintático\" para \haskellinline{case}, mas não para múltiplas equações.
    - incorrect: |
        \haskellinline{case} é uma forma simplificada de escrever múltiplas equações.
    - incorrect: |
        São conceitos totalmente independentes.
    - correct: |
        As definições de função com múltiplas equações são \"açúcar sintático\" para uma expressão \haskellinline{case}.
    - incorrect: |
        \haskellinline{case} só pode ser usado dentro de ações de E/S.

- id: "P14-02/variation-1"
  title: "case - Avaliação de Expressão"
  subject: "14: `case`"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-14", "case", "padrões"]
  question: |
    Qual o resultado da seguinte expressão?
    \begin{minted}{haskell}
    case "Haskell" of
      ('J':_) -> "Java"
      ('H':xs) -> "Resto: " ++ xs
      _ -> "Outra"
    \end{minted}
  answers:
    - incorrect: |
        \haskellinline{\"Java\"}
    - incorrect: |
        \haskellinline{\"Haskell\"}
    - correct: |
        \haskellinline{\"Resto:askell\"}
    - incorrect: |
        Erro por padrões não-exaustivos.
    - incorrect: |
        \haskellinline{\"Outra\"}

- id: "P14-03/variation-1"
  title: "case - Uso Idiomático"
  subject: "14: `case`"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-14", "case", "maybe"]
  question: |
    Para qual situação o uso de \haskellinline|case| é mais idiomático do que \haskellinline|if-then-else|?
  answers:
    - incorrect: |
        Para definir o valor de uma constante.
    - incorrect: |
        Para um teste booleano simples com duas alternativas.
    - incorrect: |
        Para realizar um cálculo matemático simples.
    - incorrect: |
        Para verificar se um número é par ou ímpar.
    - correct: |
        Para desestruturar um valor do tipo \haskellinline{Maybe a} e tratar \haskellinline{Just x} e \haskellinline{Nothing} separadamente.

- id: "P15-01/variation-1"
  title: "Aleatórios - Geração de Bool"
  subject: "15: Aleatórios"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-15", "aleatórios", "random"]
  question: |
    Para gerar um \haskellinline{Bool} aleatório (\haskellinline{True} ou \haskellinline{False}), qual ação é a mais correta?
  answers:
    - incorrect: |
        \haskellinline|random :: Bool|
    - correct: |
        \haskellinline|randomRIO (False, True) :: IO Bool|
    - incorrect: |
        \haskellinline|getLine :: IO Bool|
    - incorrect: |
        \haskellinline|randomIO :: IO Bool|
    - incorrect: |
        \haskellinline|randomRIO (0, 1) :: IO Int|

- id: "P15-02/variation-1"
  title: "Aleatórios - Geração de Double"
  subject: "15: Aleatórios"
  format: "latex"
  selection_type: "any"
  tags: ["capítulo-15", "aleatórios", "random"]
  question: |
    Para gerar um \haskellinline{Double} aleatório entre 0.0 e 100.0, qual ação é a mais correta?
  answers:
    - incorrect: |
        \haskellinline|randomRIO (0, 100) :: IO Int|
    - incorrect: |
        \haskellinline|randomIO (0.0, 100.0) :: IO Double|
    - incorrect: |
        \haskellinline|readLn :: IO Double|
    - incorrect: |
        \haskellinline|random :: IO Double|
    - correct: |
        \haskellinline|randomRIO (0.0, 100.0) :: IO Double|
